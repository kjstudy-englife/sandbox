# 初心者 OK！Docker 入門＋応用：ゼロからでも実務で使えるスキルが身に付ける

https://www.udemy.com/course/ok-docker/

## 用語・概念

ビルドコンテキスト：docker build コマンドを実行した時のカレントワーキングディレクトリ
デフォルトでは、docker はビルドコンテキストに Dockerfile があるものとして探しに行く
また、docker はビルドコンテキスト配下のファイル全てを docker デーモンに送る（コンテナ内で処理などするため）
ただ、Docker ファイルに下記のように記載していた場合、docker image build . で実行するとエラーになる
COPY ../hoge.txt ./fuga/
原因: ビルドコンテキストよりも上の階層にあるファイルは docker デーモンは知らないのでコピーできないから。
この場合は、ビルドコンテキストがそのファイルも含むようにし、Dockerfile のパスを-f で記載するなどすればいい。

.dockerignore に指定することで、ビルドコンテキストに特定のファイルを含めないことができる
（e.g. ファイル数が大きいものや、クレデンシャルな情報など）

## コマンド類

docker container run -it {imageName} {command}
よく使う-it の i は interactive,t は TTY(仮想端末)の割り当てを True にするの意味
要するにこれをつけるとターミナルと対話できていい感じに表示される

docker container exec -it {containerName} {command}
run は image を指定し、exec はコンテナを指定
run は image から container を作り、restart は停止しているコンテナを再び UP にする

## Dockerfile 内でよく使うコマンド

FROM ベースイメージの選択
RUN 実行したいこと
CMD デフォルトコマンドの上書き
ARG ビルド時に使いたい環境変数
ENV ビルド時あるいはコンテナ実行時に使いたい環境変数
WORKDIR 作業ディレクトリの変更

## イメージサイズについて

Dockerfile 内でのコマンド 1 つ 1 つがレイヤー 1 つ 1 つになる。つまりコマンド数が多いほどレイヤーが増える。
RUN コマンドが複数書かれている場合、1 つの RUN コマンドにまとめることによって 1 つのレイヤーにまとまる。
レイヤーをまとめることで余計な重複部分がなくなり、イメージの容量を小さくすることができる。

では必ずしもレイヤーをまとめるのが正かというとそうではない。鍵となるのが「ビルドはレイヤーの差分のみ実施」という考え。
RUN コマンドで全部まとめていた場合、例えば 1 つ定義を追加しようとすると、違うレイヤーになったと見なされるので、
ビルドの時にそこの部分の処理がもう一度行われることになってしまう。
しかしレイヤーごとに分けていれば、新たに追加した場合はその小さい１レイヤー分だけビルドし、あとはキャッシュされているので早い。

よって、変更が入りやすい開発初期においては、レイヤーを細かく分けておき、
変更がある程度なくなってきた段階で、イメージサイズを小さくするような運用がベストのように思われる。

## ARG と ENV の違い

ARG はイメージ作成時のみ有効
ENV はイメージ作成時とコンテナ実行時いずれも有効
→ コンテナ内に入って変数を出力すると、ARG はなくなってしまう
コンテナ内で内容によって処理を変えたり動的な処理をしたい場合は ENV じゃないとだめ
ビルド時の処理のために一時的な変数が欲しい場合は ARG で十分。
ARG は Dockerfile のスコープ内のみに影響する（コンテナ実行時には何も影響ない）ので、コンテナ内で実行する必要がない場合は ARG を使う方が望ましい。
ARG でいいなら ARG、ダメなら ENV って感じ。

## マルチステージビルド

最終的にコンテナに必要なもののみを持たせたい場合に使える
例えば、必要なファイルを準備するためにコンパイラが途中で必要だが、あくまで必要なのはそれによってコンパイルされたファイルであり、
コンパイラ自体は不要であるといった場合、
1 つ目のステージ；ベースイメージをコンパイラ(e.g. gcc)とし、ファイルをコンパイル
2 つ目のステージ；ベースイメージを Linux 実行環境とし、1 つ目のステージでコンパイルされたファイルをコピーしてきて実行
のようなことができる。image としては Linux 分しないのでイメージサイズの増加を防げる。

また、共通部分と環境依存部分を 1 つの Dockerfile に書くこともできる
共通部分は例えば common のようなイメージで名前をつけておき、各環境部分ではその common をベースとし、環境別の処理を書く。
build 時のコマンドで --target でイメージを選択することで、環境ごとに処理を分けたイメージをビルドすることができる

## Docker とストレージ

永続的なストレージ管理の方法としては、「ボリューム」と「バインドマウント」の 2 種
ボリュームは Docker サイドで管理されるストレージで、自由に作ったり削除できる
ローカルで編集したものをコンテナ内と共有したい場合はバインドマウント

docker container run -v {vol}:{path} {image} // ボリューム
docker container run -v {host_path}:{path} {image} // バインドマウント

バインドマウントの時はローカルの絶対パスを指定せねばならんので普通にやると以下のようになる
docker container run -it -v /Users/xxx/git/udemy-study/ok-docker/docker/my-dir:/app --name bild-container ubuntu:20.04
この絶対パスの部分は $(pwd) に置き換えると楽

Docker 的には外乱による副作用を防ぐために、基本的にはボリュームを使うことが推奨されているが、
ホスト側からデータにアクセスしたいときはバインドマウント。
ボリューム領域を使うのは DB のデータを保存するなど。

## コンテナの接続

コンテナ内の App などに接続するには、その App が割り当てられているポート番号を指定する必要がある。
ただし、外部ブラウザからそのポート番号を指定したとしても、コンテナが起動しているホストはその番号を知らない。
なので、ホストーコンテナのポートをあらかじめ繋いでおくことで、外部ブラウザからコンテナに接続できるようになる
docker container run -p {hostPort:ContainerPort} {image}

コンテナ間の接続を行うにはブリッジネットワークを用いる。
特に指定しなければ、コンテナはデフォルトで提供される bridge ネットワークに接続される。
自分でブリッジネットワークを作成し、コンテナ起動時に--network オプションで指定することも可能

デフォルトの bridge ネットワークでは名前解決ができないので、名前解決したい場合は自分でブリッジネットワークを作る必要がある
（ただし docker-compose で起動した場合、コンテナたちは自動的にカスタムネットワークにアタッチされた状態となるので指定する必要がない）
